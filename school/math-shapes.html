<!DOCTYPE html>
<html lang="en">
<head>
  <title>Osyra's Worksheets - Name the Shape</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      /* Coffee Base Colors */
      --espresso: #1e1610;
      --dark-mocha: #2a1e14;
      --coffee-bean: #453024;

      /* Cream & Milk Colors */
      --steamed-milk: #f5f5dc;
      --light-cream: #f8e5c8;
      --half-and-half: #d2b48c;

      /* Syrup & Flavor Colors */
      --caramel: #d2691e;
      --pumpkin-spice: #b68d40;
      --mocha: #8b4513;

      /* Darker Syrups */
      --dark-caramel: #38271e;
      --toasted-almond: #5c4937;
      --dark-chocolate: #120d08;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      background: linear-gradient(135deg, var(--dark-chocolate) 0%, var(--espresso) 100%);
      color: var(--steamed-milk);
      min-height: 100vh;
      padding: 20px;
    }

    .app-container {
      max-width: 1400px;
      margin: 0 auto;
    }

    .app-header {
      background: var(--dark-caramel);
      border: 1px solid var(--coffee-bean);
      border-radius: 12px;
      padding: 25px 30px;
      margin-bottom: 20px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
      text-align: center;
    }

    .app-title {
      font-size: 32px;
      font-weight: 600;
      color: var(--caramel);
    }

    .controls-panel {
      background: var(--dark-mocha);
      border: 1px solid var(--coffee-bean);
      padding: 20px;
      border-radius: 12px;
      margin-bottom: 20px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .controls {
      display: flex;
      gap: 15px;
      align-items: center;
      flex-wrap: wrap;
    }

    label {
      display: flex;
      flex-direction: column;
      gap: 6px;
      font-size: 13px;
      font-weight: 500;
      color: var(--half-and-half);
    }

    select, input[type="number"] {
      padding: 10px 14px;
      font-size: 14px;
      border: 2px solid var(--coffee-bean);
      border-radius: 8px;
      background: var(--dark-caramel);
      color: var(--steamed-milk);
      transition: all 0.2s ease;
      font-family: inherit;
    }

    select:focus, input[type="number"]:focus {
      outline: none;
      border-color: var(--pumpkin-spice);
      background: var(--espresso);
    }

    button {
      padding: 10px 20px;
      font-size: 14px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s ease;
      font-family: inherit;
    }

    button.primary {
      background: var(--pumpkin-spice);
      color: var(--espresso);
    }

    button.primary:hover {
      background: var(--caramel);
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(182, 141, 64, 0.3);
    }

    button.secondary {
      background: var(--mocha);
      color: var(--steamed-milk);
    }

    button.secondary:hover {
      background: var(--coffee-bean);
      transform: translateY(-1px);
    }

    .worksheet {
      background: var(--dark-mocha);
      border: 1px solid var(--coffee-bean);
      padding: 30px;
      border-radius: 12px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
    }

    .worksheet-header {
      text-align: center;
      margin-bottom: 25px;
      padding-bottom: 20px;
      border-bottom: 2px solid var(--coffee-bean);
    }

    .worksheet-header h2 {
      font-size: 24px;
      color: var(--caramel);
      margin-bottom: 10px;
      font-weight: 600;
    }

    .worksheet-header .info {
      font-size: 13px;
      display: flex;
      justify-content: space-between;
      margin-top: 12px;
      color: var(--half-and-half);
    }

    .canvas-container {
      width: 100%;
      position: relative;
      display: flex;
      justify-content: center;
    }

    #questionsCanvas {
      border: 2px solid var(--coffee-bean);
      border-radius: 8px;
      background: #faf8f3;
      display: block;
    }

    #answersCanvas {
      border: 2px solid transparent;
      border-radius: 8px;
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      pointer-events: none;
      background: transparent;
      display: none;
    }

    #answersCanvas.show {
      display: block;
    }

    .print-page {
      display: none;
    }

    .back-link {
      display: block;
      padding: 8px 16px;
      background: var(--pumpkin-spice);
      color: var(--espresso);
      text-decoration: none;
      border-radius: 8px;
      font-weight: 500;
      font-size: 14px;
      transition: all 0.2s ease;
      float: left;
    }

    .back-link:hover {
      background: var(--caramel);
      transform: translateY(-1px);
    }

    @media print {
      body {
        background: white;
        padding: 0;
        margin: 0;
      }

      .app-header, .controls-panel, .no-print {
        display: none !important;
      }

      .worksheet {
        display: none !important;
      }

      .print-page {
        display: block;
        page-break-after: always;
        width: 7.5in;
        height: 10in;
        margin: 0;
        padding: 0;
        position: relative;
      }

      .print-page:last-child {
        page-break-after: auto;
      }

      .print-page canvas {
        width: 7.5in !important;
        height: 10in !important;
        display: block;
        image-rendering: -webkit-optimize-contrast;
        image-rendering: crisp-edges;
        background: white !important;
      }

      @page {
        margin: 0.5in;
        size: A4 portrait;
      }
    }

    @media (max-width: 768px) {
      .controls {
        flex-direction: column;
        align-items: stretch;
      }
    }
  </style>
</head>
<body>

  <div class="app-container">
    <div class="app-header">
      <a class="back-link" href="index.html">BACK</a>
      <h1 class="app-title">Osyra's Worksheets
        <a href="https://librecounter.org/referer/show" target="_blank">
          <img style="float: right;display: inline;width:20px;" src="https://librecounter.org/outline-orange.svg" referrerPolicy="unsafe-url" />
        </a>
      </h1>
    </div>

    <div class="controls-panel no-print">
      <div class="controls">
        <label>
          <span>Number of Shapes:</span>
          <select id="numShapes">
            <option value="4">4</option>
            <option value="8">8</option>
            <option value="12" selected>12</option>
            <option value="16">16</option>
            <option value="20">20</option>
            <option value="24">24</option>
            <option value="32">32</option>
            <option value="40">40</option>
          </select>
        </label>

        <label>
          <span>Difficulty:</span>
          <select id="difficulty">
            <option value="easy">Easy (Basic Shapes)</option>
            <option value="medium" selected>Medium (More Shapes)</option>
            <option value="hard">Hard (All Shapes)</option>
          </select>
        </label>

        <button class="primary" onclick="generateWorksheet()">Generate Worksheet</button>
        <button class="secondary" onclick="toggleAnswers()">Show Answers</button>
        <button class="secondary" onclick="window.print()">Print Worksheet</button>
      </div>
    </div>

    <div class="worksheet">
      <div class="worksheet-header">
        <h2>Name the Shape</h2>
        <div class="info">
          <span>Name: _______________________</span>
          <span>Date: _______________________</span>
          <span id="scoreField">Score: _______ / 12</span>
        </div>
      </div>
      <div class="canvas-container">
        <canvas id="questionsCanvas"></canvas>
        <canvas id="answersCanvas"></canvas>
      </div>
    </div>

    <!-- Print-only pages -->
    <div id="printContainer"></div>
  </div>

  <script>
    // Shape definitions with drawing functions
    const SHAPES = {
      easy: [
        { name: 'Circle', draw: (ctx, x, y, size) => { ctx.beginPath(); ctx.arc(x, y, size * 0.4, 0, Math.PI * 2); ctx.stroke(); } },
        { name: 'Square', draw: (ctx, x, y, size) => { const s = size * 0.7; ctx.strokeRect(x - s/2, y - s/2, s, s); } },
        { name: 'Triangle', draw: (ctx, x, y, size) => { const s = size * 0.4; ctx.beginPath(); ctx.moveTo(x, y - s); ctx.lineTo(x + s, y + s); ctx.lineTo(x - s, y + s); ctx.closePath(); ctx.stroke(); } },
        { name: 'Rectangle', draw: (ctx, x, y, size) => { const w = size * 0.8; const h = size * 0.5; ctx.strokeRect(x - w/2, y - h/2, w, h); } },
        { name: 'Oval', draw: (ctx, x, y, size) => { ctx.beginPath(); ctx.ellipse(x, y, size * 0.45, size * 0.3, 0, 0, Math.PI * 2); ctx.stroke(); } },
        { name: 'Diamond', draw: (ctx, x, y, size) => { const s = size * 0.4; ctx.beginPath(); ctx.moveTo(x, y - s); ctx.lineTo(x + s, y); ctx.lineTo(x, y + s); ctx.lineTo(x - s, y); ctx.closePath(); ctx.stroke(); } },
      ],
      medium: [
        { name: 'Pentagon', draw: (ctx, x, y, size) => { drawPolygon(ctx, x, y, size * 0.4, 5); } },
        { name: 'Hexagon', draw: (ctx, x, y, size) => { drawPolygon(ctx, x, y, size * 0.4, 6); } },
        { name: 'Star', draw: (ctx, x, y, size) => { drawStar(ctx, x, y, size * 0.4, 5); } },
        { name: 'Heart', draw: (ctx, x, y, size) => { drawHeart(ctx, x, y, size * 0.4); } },
        { name: 'Crescent', draw: (ctx, x, y, size) => { drawCrescent(ctx, x, y, size * 0.4); } },
        { name: 'Arrow', draw: (ctx, x, y, size) => { drawArrow(ctx, x, y, size * 0.4); } },
      ],
      hard: [
        { name: 'Octagon', draw: (ctx, x, y, size) => { drawPolygon(ctx, x, y, size * 0.4, 8); } },
        { name: 'Trapezoid', draw: (ctx, x, y, size) => { drawTrapezoid(ctx, x, y, size * 0.4); } },
        { name: 'Parallelogram', draw: (ctx, x, y, size) => { drawParallelogram(ctx, x, y, size * 0.4); } },
        { name: 'Rhombus', draw: (ctx, x, y, size) => { const s = size * 0.35; ctx.beginPath(); ctx.moveTo(x, y - s); ctx.lineTo(x + s * 0.7, y); ctx.lineTo(x, y + s); ctx.lineTo(x - s * 0.7, y); ctx.closePath(); ctx.stroke(); } },
        { name: 'Cross', draw: (ctx, x, y, size) => { drawCross(ctx, x, y, size * 0.4); } },
        { name: 'Semicircle', draw: (ctx, x, y, size) => { ctx.beginPath(); ctx.arc(x, y, size * 0.4, Math.PI, 0); ctx.closePath(); ctx.stroke(); } },
      ]
    };

    function drawPolygon(ctx, x, y, radius, sides) {
      ctx.beginPath();
      for (let i = 0; i < sides; i++) {
        const angle = (i * 2 * Math.PI / sides) - Math.PI / 2;
        const px = x + radius * Math.cos(angle);
        const py = y + radius * Math.sin(angle);
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.stroke();
    }

    function drawStar(ctx, x, y, radius, points) {
      ctx.beginPath();
      for (let i = 0; i < points * 2; i++) {
        const r = i % 2 === 0 ? radius : radius * 0.4;
        const angle = (i * Math.PI / points) - Math.PI / 2;
        const px = x + r * Math.cos(angle);
        const py = y + r * Math.sin(angle);
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.stroke();
    }

    function drawHeart(ctx, x, y, size) {
      ctx.beginPath();
      ctx.moveTo(x, y + size * 0.7);
      ctx.bezierCurveTo(x - size * 1.2, y - size * 0.3, x - size * 0.4, y - size, x, y - size * 0.4);
      ctx.bezierCurveTo(x + size * 0.4, y - size, x + size * 1.2, y - size * 0.3, x, y + size * 0.7);
      ctx.stroke();
    }

    function drawCrescent(ctx, x, y, size) {
      // Two circles of same radius, offset horizontally
      const r = size;
      const offset = size * 0.5; // offset for inner circle

      // Calculate intersection points using circle-circle intersection
      // For two circles with same radius r, centers at distance d apart:
      // intersection points are at x = d/2 from first center, y = ±sqrt(r² - (d/2)²)
      const d = offset;
      const halfD = d / 2;
      const hSquared = r * r - halfD * halfD;

      // Safety check - if circles don't intersect properly, draw a simple arc
      if (hSquared <= 0) {
        ctx.beginPath();
        ctx.arc(x, y, r, Math.PI * 0.25, Math.PI * 1.75, false);
        ctx.stroke();
        return;
      }

      const h = Math.sqrt(hSquared);

      // Calculate angles for both circles at intersection points
      const angle1Top = Math.atan2(-h, halfD);
      const angle1Bottom = Math.atan2(h, halfD);
      const angle2Top = Math.atan2(-h, halfD - offset);
      const angle2Bottom = Math.atan2(h, halfD - offset);

      // Shift to center the crescent
      const shiftLeft = offset;

      ctx.beginPath();
      // Outer arc (left side of first circle)
      ctx.arc(x - shiftLeft, y, r, angle1Bottom, angle1Top, true);
      // Inner arc (left side of second circle)
      ctx.arc(x + offset - shiftLeft, y, r, angle2Top, angle2Bottom, false);
      ctx.closePath();
      ctx.stroke();
    }

    function drawArrow(ctx, x, y, size) {
      ctx.beginPath();
      ctx.moveTo(x, y - size);
      ctx.lineTo(x + size * 0.6, y);
      ctx.lineTo(x + size * 0.25, y);
      ctx.lineTo(x + size * 0.25, y + size);
      ctx.lineTo(x - size * 0.25, y + size);
      ctx.lineTo(x - size * 0.25, y);
      ctx.lineTo(x - size * 0.6, y);
      ctx.closePath();
      ctx.stroke();
    }

    function drawTrapezoid(ctx, x, y, size) {
      ctx.beginPath();
      ctx.moveTo(x - size * 0.5, y - size * 0.5);
      ctx.lineTo(x + size * 0.5, y - size * 0.5);
      ctx.lineTo(x + size * 0.8, y + size * 0.5);
      ctx.lineTo(x - size * 0.8, y + size * 0.5);
      ctx.closePath();
      ctx.stroke();
    }

    function drawParallelogram(ctx, x, y, size) {
      ctx.beginPath();
      ctx.moveTo(x - size * 0.5, y - size * 0.4);
      ctx.lineTo(x + size * 0.8, y - size * 0.4);
      ctx.lineTo(x + size * 0.5, y + size * 0.4);
      ctx.lineTo(x - size * 0.8, y + size * 0.4);
      ctx.closePath();
      ctx.stroke();
    }

    function drawCross(ctx, x, y, size) {
      const w = size * 0.3;
      ctx.beginPath();
      ctx.moveTo(x - w, y - size);
      ctx.lineTo(x + w, y - size);
      ctx.lineTo(x + w, y - w);
      ctx.lineTo(x + size, y - w);
      ctx.lineTo(x + size, y + w);
      ctx.lineTo(x + w, y + w);
      ctx.lineTo(x + w, y + size);
      ctx.lineTo(x - w, y + size);
      ctx.lineTo(x - w, y + w);
      ctx.lineTo(x - size, y + w);
      ctx.lineTo(x - size, y - w);
      ctx.lineTo(x - w, y - w);
      ctx.closePath();
      ctx.stroke();
    }

    // Global state
    let currentShapes = [];
    let shuffledWordBank = [];
    let showingAnswers = false;
    let questionsCanvas, answersCanvas;
    let questionsCtx, answersCtx;

    function initCanvases() {
      questionsCanvas = document.getElementById('questionsCanvas');
      answersCanvas = document.getElementById('answersCanvas');
      questionsCtx = questionsCanvas.getContext('2d');
      answersCtx = answersCanvas.getContext('2d');
    }

    function getAvailableShapes(difficulty) {
      let shapes = [...SHAPES.easy];
      if (difficulty === 'medium' || difficulty === 'hard') {
        shapes = shapes.concat(SHAPES.medium);
      }
      if (difficulty === 'hard') {
        shapes = shapes.concat(SHAPES.hard);
      }
      return shapes;
    }

    function shuffleArray(array) {
      const shuffled = [...array];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }

    function drawWorksheet() {
      const numShapes = currentShapes.length;
      const cols = 4;
      const margin = 30;
      const wordBankHeight = 80;
      const pageHeight = 900;
      const A4_WIDTH = 794;

      const availableWidth = A4_WIDTH - (2 * margin);

      // Fixed cell dimensions for consistent shape sizes
      const cellWidth = availableWidth / cols;
      const cellHeight = 180;
      const shapeSize = Math.min(cellWidth, cellHeight) * 0.5;

      // Calculate how many rows fit on first page (with word bank) and subsequent pages
      const firstPageShapesStartY = margin + wordBankHeight + 20;
      const subsequentPageStartY = margin;
      const availableHeightFirstPage = pageHeight - firstPageShapesStartY - margin;
      const availableHeightOtherPages = pageHeight - (2 * margin);

      const maxRowsFirstPage = Math.floor(availableHeightFirstPage / cellHeight);
      const maxRowsPerPage = Math.floor(availableHeightOtherPages / cellHeight);
      const maxShapesFirstPage = maxRowsFirstPage * cols;
      const maxShapesPerPage = maxRowsPerPage * cols;

      // Calculate total pages needed
      let numPages = 1;
      let remainingShapes = numShapes - maxShapesFirstPage;
      if (remainingShapes > 0) {
        numPages += Math.ceil(remainingShapes / maxShapesPerPage);
      }

      const totalHeight = numPages * pageHeight;

      // Resize canvases
      questionsCanvas.width = A4_WIDTH;
      questionsCanvas.height = totalHeight;
      answersCanvas.width = A4_WIDTH;
      answersCanvas.height = totalHeight;

      // Update display size
      const containerWidth = questionsCanvas.parentElement.clientWidth;
      const scale = Math.min(1, containerWidth / A4_WIDTH);

      questionsCanvas.style.width = (A4_WIDTH * scale) + 'px';
      questionsCanvas.style.height = (totalHeight * scale) + 'px';
      answersCanvas.style.width = (A4_WIDTH * scale) + 'px';
      answersCanvas.style.height = (totalHeight * scale) + 'px';

      // Clear canvases
      questionsCtx.fillStyle = '#ffffff';
      questionsCtx.fillRect(0, 0, A4_WIDTH, totalHeight);
      answersCtx.clearRect(0, 0, A4_WIDTH, totalHeight);

      // Draw page separators
      if (numPages > 1) {
        questionsCtx.strokeStyle = '#cccccc';
        questionsCtx.lineWidth = 1;
        questionsCtx.setLineDash([5, 5]);
        for (let page = 1; page < numPages; page++) {
          const pageY = page * pageHeight;
          questionsCtx.beginPath();
          questionsCtx.moveTo(0, pageY);
          questionsCtx.lineTo(A4_WIDTH, pageY);
          questionsCtx.stroke();
        }
        questionsCtx.setLineDash([]);
      }

      // Draw word bank on first page
      const wordBankY = margin;
      questionsCtx.fillStyle = '#f5f5f5';
      questionsCtx.fillRect(margin, wordBankY, availableWidth, wordBankHeight);
      questionsCtx.strokeStyle = '#d4c9ba';
      questionsCtx.lineWidth = 2;
      questionsCtx.strokeRect(margin, wordBankY, availableWidth, wordBankHeight);

      // Word bank title
      questionsCtx.fillStyle = '#5d4e37';
      questionsCtx.font = 'bold 14px Arial';
      questionsCtx.textAlign = 'left';
      questionsCtx.textBaseline = 'top';
      questionsCtx.fillText('Word Bank:', margin + 10, wordBankY + 8);

      // Draw word bank words (use stored shuffled order)
      questionsCtx.font = '16px Arial';
      questionsCtx.textAlign = 'center';
      questionsCtx.textBaseline = 'middle';
      const wordsPerRow = Math.ceil(shuffledWordBank.length / 2);
      const wordSpacing = availableWidth / (wordsPerRow + 1);

      shuffledWordBank.forEach((name, i) => {
        const row = Math.floor(i / wordsPerRow);
        const col = i % wordsPerRow;
        const wordX = margin + wordSpacing * (col + 1);
        const wordY = wordBankY + 35 + (row * 22);
        questionsCtx.fillStyle = '#3d3d3d';
        questionsCtx.fillText(name, wordX, wordY);
      });

      // Draw shapes
      currentShapes.forEach((shape, index) => {
        const col = index % cols;

        // Calculate which page and row this shape is on
        let currentPage, rowOnPage, shapesStartY;

        if (index < maxShapesFirstPage) {
          // First page
          currentPage = 0;
          rowOnPage = Math.floor(index / cols);
          shapesStartY = firstPageShapesStartY;
        } else {
          // Subsequent pages
          const indexAfterFirstPage = index - maxShapesFirstPage;
          currentPage = 1 + Math.floor(indexAfterFirstPage / maxShapesPerPage);
          const indexOnThisPage = indexAfterFirstPage % maxShapesPerPage;
          rowOnPage = Math.floor(indexOnThisPage / cols);
          shapesStartY = subsequentPageStartY;
        }

        const cellX = margin + col * cellWidth;
        const cellY = (currentPage * pageHeight) + shapesStartY + (rowOnPage * cellHeight);
        const centerX = cellX + cellWidth / 2;
        const centerY = cellY + cellHeight / 2 - 15;

        // Draw cell border
        questionsCtx.strokeStyle = '#e0e0e0';
        questionsCtx.lineWidth = 1;
        questionsCtx.strokeRect(cellX + 5, cellY + 5, cellWidth - 10, cellHeight - 10);

        // Draw number
        questionsCtx.fillStyle = '#8b7355';
        questionsCtx.font = 'bold 14px Arial';
        questionsCtx.textAlign = 'left';
        questionsCtx.textBaseline = 'top';
        questionsCtx.fillText(`${index + 1}.`, cellX + 10, cellY + 10);

        // Draw shape
        questionsCtx.strokeStyle = '#3d3d3d';
        questionsCtx.lineWidth = 2.5;
        shape.draw(questionsCtx, centerX, centerY, shapeSize);

        // Draw answer line
        const lineY = cellY + cellHeight - 25;
        questionsCtx.strokeStyle = '#5d4e37';
        questionsCtx.lineWidth = 1;
        questionsCtx.beginPath();
        questionsCtx.moveTo(cellX + 20, lineY);
        questionsCtx.lineTo(cellX + cellWidth - 20, lineY);
        questionsCtx.stroke();

        // Draw answer on overlay
        if (showingAnswers) {
          answersCtx.fillStyle = '#c75000';
          answersCtx.font = 'bold 14px Arial';
          answersCtx.textAlign = 'center';
          answersCtx.textBaseline = 'alphabetic';
          answersCtx.fillText(shape.name, centerX, lineY - 3);
        }
      });
    }

    function createPrintPages() {
      const printContainer = document.getElementById('printContainer');
      printContainer.innerHTML = '';

      const pageHeight = 900;
      const A4_WIDTH = 794;
      const numPages = Math.ceil(questionsCanvas.height / pageHeight);

      for (let page = 0; page < numPages; page++) {
        const pageDiv = document.createElement('div');
        pageDiv.className = 'print-page';

        const pageCanvas = document.createElement('canvas');
        pageCanvas.width = A4_WIDTH;
        pageCanvas.height = pageHeight;

        const ctx = pageCanvas.getContext('2d');

        // Fill white background
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, 0, A4_WIDTH, pageHeight);

        // Draw header on first page only
        if (page === 0) {
          const headerHeight = 60;

          ctx.strokeStyle = '#333333';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(0, headerHeight);
          ctx.lineTo(A4_WIDTH, headerHeight);
          ctx.stroke();

          ctx.fillStyle = '#5d4e37';
          ctx.font = 'bold 18px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('Name the Shape', 397, 25);

          ctx.font = '12px Arial';
          ctx.textAlign = 'left';
          ctx.fillText('Name: _______________________', 30, 50);

          ctx.textAlign = 'center';
          ctx.fillText('Date: _______________________', 397, 50);

          ctx.textAlign = 'right';
          ctx.fillText(`Score: _______ / ${currentShapes.length}`, 764, 50);

          // Copy worksheet content (offset for header)
          ctx.drawImage(questionsCanvas, 0, 0, A4_WIDTH, pageHeight - headerHeight, 0, headerHeight, A4_WIDTH, pageHeight - headerHeight);

          if (showingAnswers) {
            ctx.drawImage(answersCanvas, 0, 0, A4_WIDTH, pageHeight - headerHeight, 0, headerHeight, A4_WIDTH, pageHeight - headerHeight);
          }
        } else {
          // For subsequent pages, copy from the corresponding section of the main canvas
          const sourceY = page * pageHeight;
          ctx.drawImage(questionsCanvas, 0, sourceY, A4_WIDTH, pageHeight, 0, 0, A4_WIDTH, pageHeight);

          if (showingAnswers) {
            ctx.drawImage(answersCanvas, 0, sourceY, A4_WIDTH, pageHeight, 0, 0, A4_WIDTH, pageHeight);
          }

          // Add page number
          ctx.fillStyle = '#8b7355';
          ctx.font = '12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(`Page ${page + 1}`, A4_WIDTH / 2, pageHeight - 20);
        }

        pageDiv.appendChild(pageCanvas);
        printContainer.appendChild(pageDiv);
      }
    }

    function generateWorksheet() {
      const numShapes = parseInt(document.getElementById('numShapes').value);
      const difficulty = document.getElementById('difficulty').value;

      const availableShapes = getAvailableShapes(difficulty);

      // Select random shapes (allowing duplicates if needed)
      currentShapes = [];
      const shuffled = shuffleArray(availableShapes);

      for (let i = 0; i < numShapes; i++) {
        currentShapes.push(shuffled[i % shuffled.length]);
      }

      // Shuffle the selected shapes
      currentShapes = shuffleArray(currentShapes);

      // Create and store shuffled word bank
      const uniqueNames = [...new Set(currentShapes.map(s => s.name))];
      shuffledWordBank = shuffleArray(uniqueNames);

      // Update score field
      document.getElementById('scoreField').textContent = `Score: _______ / ${numShapes}`;

      showingAnswers = false;
      answersCanvas.classList.remove('show');

      drawWorksheet();
      setTimeout(() => createPrintPages(), 100);
    }

    function toggleAnswers() {
      if (currentShapes.length === 0) {
        alert('Please generate a worksheet first.');
        return;
      }

      showingAnswers = !showingAnswers;
      const button = event.target;
      button.textContent = showingAnswers ? 'Hide Answers' : 'Show Answers';

      if (showingAnswers) {
        answersCanvas.classList.add('show');
      } else {
        answersCanvas.classList.remove('show');
      }

      drawWorksheet();
      setTimeout(() => createPrintPages(), 100);
    }

    // Initialize
    window.onload = function() {
      initCanvases();
      generateWorksheet();
    };

    window.onresize = function() {
      if (questionsCanvas && currentShapes.length > 0) {
        drawWorksheet();
      }
    };
  </script>
</body>
</html>
